<!DOCTYPE html>
<!-- Legal Footnote: This content is subject to copyright and should not be reproduced without permission. -->
<!-- Written and created by Thomas John-Michael de Beer, feel free to contact me via tjdebeer@gmail.com  -->
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="⧉">
    <meta name="theme-color" content="#000000">
    <title>⧉</title>
    <link rel="apple-touch-icon" href="512x512.png">
    <link rel="icon" href="icons/favicon.png">
    <link rel="manifest" href="manifest.json">
    <style>
        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            background-color: black;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden;
        }

        .container {
            position: relative;
            width: calc(100% - 22vw);
            height: calc(100% - 22vw);
        }

        .menuButton, .ShareButton, .plus, .photo, .center {
            position: absolute;
            width: 50px;
            height: 50px;
            background-color: white;
        }

        .menuButton {
            top: 0;
            left: 0;
        }

        .ShareButton {
            top: 0;
            right: 0;
        }

        .plus {
            bottom: 0;
            left: 0;
        }

        .photo {
            bottom: 0;
            right: 0;
        }

        .center {
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }

        svg {
            width: 100%;
            height: 100%;
        }

        #startCameraButton {
            user-select: none;
            -webkit-tap-highlight-color: transparent;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: black;
            color: white;
            border: none;
            cursor: pointer;
            outline: none;
            transition: opacity 3s ease-in-out;
            z-index: 13;
        }

#startCameraButton img.fade-in {
    opacity: 1;
}

#startCameraButton img.fade-out {
    opacity: 0;
}

#startCameraButton img {
    width: 222px;
    height: auto;
    transition: opacity 3s ease-in-out;
    opacity: 0;
}
    </style>
</head>
<body>

<button id="startCameraButton">
    <img src="presplash.webp" alt="Start Camera">
</button>
    
    <div class="container">
        <div class="MenuButton">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100">
                <rect width="100" height="100" fill="white"/>
            </svg>
        </div>
        <div class="ShareButton">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100">
                <rect width="100" height="100" fill="white"/>
            </svg>
        </div>
        <div class="plus">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100">
                <rect width="100" height="100" fill="white"/>
            </svg>
        </div>
        <div class="photo">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100">
                <rect width="100" height="100" fill="white"/>
            </svg>
        </div>
        <div class="center">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100">
                <rect width="100" height="100" fill="white"/>
            </svg>
        </div>
    </div>
</body>
<script>

const shareButton = document.getElementById('ShareButton');
const qrContainer = document.getElementById('QRContainer');

shareButton.addEventListener('click', () => {
QRContainer.style.display = QRContainer.style.display === 'none' ? 'block' : 'none';
shareButton.style.opacity = shareButton.style.opacity === '0.3' ? '0.9' : '0.3';
});

function setTemporaryOpacity(element, opacity, duration) {
    element.style.opacity = opacity;
    setTimeout(function () {
        element.style.opacity = 0.9;
    }, duration);
}

function open_file_chooser() {
    if (intervalId) {
        clearInterval(intervalId);
    }

    var fileInput = document.createElement("input");
    fileInput.type = "file";
    fileInput.accept = "image/*";
    fileInput.click();

    fileInput.addEventListener("change", function () {
        var selectedFile = this.files[0];
        if (selectedFile) {
                processAndSendImage(selectedFile);
            if (intervalCallback) {
                if (MENUVAR === 0) {
                    intervalId = setInterval(intervalCallback, 333);
                } else {
                    clearInterval(intervalId);
                }
            }
        }
    });

    fileInput.addEventListener("cancel", function () {
    });
}

function processAndSendImage(selectedFile) {
    var canvas = document.createElement("canvas");
    var ctx = canvas.getContext("2d");
    var img = new Image();

    img.onload = function () {
        const borderSize = 10;
        canvas.width = img.width + 2 * borderSize;
        canvas.height = img.height + 2 * borderSize;
        ctx.fillStyle = "white";
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.drawImage(img, borderSize, borderSize, img.width, img.height);
        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        const transformedImageData = processImage(imageData);
        const processedImageArray = SequenceandSend(transformedImageData);

        if (processedImageArray) {
            if (SAVED_LINK.trim() === '') {
                FRAME(processedImageArray);
            } else {
                ARCHIVE(processedImageArray, SAVED_LINK);
            }
        } else {
            console.error('Processed image is undefined. Cannot proceed.');
        }
    };

    img.src = URL.createObjectURL(selectedFile);
}

const openTextInputButton = document.getElementById('openTextInputButton');
const textInputContainer = document.getElementById('textInputContainer');
const textInput = document.getElementById('textInput');

let SAVED_LINK = '';

openTextInputButton.addEventListener('click', () => {
        openTextInputButton.style.opacity = 0.7;
        textInputContainer.style.display = 'block';
        textInput.focus();
        textInput.placeholder = SAVED_LINK;
});

textInput.addEventListener('input', () => {
    SAVED_LINK = textInput.value;
    updateOpenButtonOpacity();
});

textInput.addEventListener('keydown', (event) => {
    if (event.key === 'Enter' || event.key === 'Go') {
        textInputContainer.style.display = 'none';
        textInput.value = '';
        updateOpenButtonOpacity();
    }
});

function updateOpenButtonOpacity() {
    if (SAVED_LINK && SAVED_LINK.trim() !== '') {
        openTextInputButton.style.opacity = '0.9';
    } else {
        openTextInputButton.style.opacity = '0.2';
    }
}

let intervalId;
let intervalCallback;
let CameraStatus = false;
const cameraView = document.getElementById('cameraView');
const startCameraButton = document.getElementById('startCameraButton');
const takePhotoButton = document.getElementById('takePhotoButton');
const photoCanvas = document.getElementById('photoCanvas');
const canvasContext = photoCanvas.getContext('2d');
let stream;
let currentCameraIndex = 0;

async function startCamera() {
    try {
        let selectedDeviceId = localStorage.getItem('selectedCamera');

        if (!selectedDeviceId) {
            const devices = await navigator.mediaDevices.enumerateDevices();
            const videoDevices = devices.filter(device => device.kind === 'videoinput');

            if (videoDevices.length === 0) {
                throw new Error('No video devices found.');
            }

            currentCameraIndex = videoDevices.length > 1 ? 1 : 0;
            selectedDeviceId = videoDevices[currentCameraIndex].deviceId;

            localStorage.setItem('selectedCamera', selectedDeviceId);
        }

        const constraints = {
            video: { deviceId: selectedDeviceId },
            audio: false,
        };

        stream = await navigator.mediaDevices.getUserMedia(constraints);
        cameraView.srcObject = stream;
        startCameraButton.disabled = true;
        takePhotoButton.disabled = false;
        startCameraButton.style.display = 'none';
        CameraStatus = true;
        openButton.style.opacity = '0';
        intervalCallback = () => {
            takePhoto();
        };
        intervalId = setInterval(intervalCallback, 333);

    } catch (error) {
        startCameraButton.disabled = true;
        startCameraButton.style.opacity = '0';
        startCameraButton.style.pointerEvents = 'none';
        takePhotoButton.disabled = true;
        takePhotoButton.style.opacity = '0';
        takePhotoButton.style.pointerEvents = 'none';
        console.error('Error starting camera:', error);
    }
}

async function switchCamera() {
    try {
        stopCamera();
        const devices = await navigator.mediaDevices.enumerateDevices();
        const videoDevices = devices.filter(device => device.kind === 'videoinput');

        if (videoDevices.length === 0) {
            throw new Error('No video devices found.');
        }

        currentCameraIndex = (currentCameraIndex + 1) % videoDevices.length;
        const selectedDeviceId = videoDevices[currentCameraIndex].deviceId;

        localStorage.setItem('selectedCamera', selectedDeviceId);

        await startCamera();
    } catch (error) {
        handleCameraError(error);
    }
}

function stopCamera() {
    clearInterval(intervalId);

    if (stream) {
        const tracks = stream.getTracks();
        tracks.forEach(track => {
            track.stop();
        });
    }
}

function handleSwipe() {
    const deltaY = touchendY - touchstartY;

    if (deltaY > 50) {
        switchCamera();
    }
}

document.addEventListener('keydown', (event) => {
    if (event.key === 'ArrowUp') {
        switchCamera();
    }
});

let touchstartY;
let touchendY;

document.addEventListener('touchstart', (event) => {
    touchstartY = event.touches[0].clientY;
});

document.addEventListener('touchmove', (event) => {
    event.preventDefault();
});

document.addEventListener('touchend', (event) => {
    touchendY = event.changedTouches[0].clientY;
    handleSwipe();
});

document.addEventListener('DOMContentLoaded', () => {
    const startCameraButton = document.getElementById('startCameraButton');
    const startCameraImage = startCameraButton.querySelector('img');

    startCameraButton.addEventListener('click', () => {
        startCameraButton.style.display = 'none';
        startCamera();
    });

    setTimeout(() => {
        if (startCameraButton.style.display !== 'none') {
            startCameraImage.classList.add('fade-in');

            setTimeout(() => {
                startCameraImage.classList.remove('fade-in');
                startCameraImage.classList.add('fade-out');

                setTimeout(() => {
                    if (startCameraButton.style.display !== 'none') {
                        startCameraButton.style.display = 'none';
                        startCamera();
                    }
                }, 3000);
            }, 3000);
        }
    }, 50);
});


function takePhoto() {
    if (stream) {
        photoCanvas.width = cameraView.videoWidth;
        photoCanvas.height = cameraView.videoHeight;
        canvasContext.drawImage(cameraView, 0, 0, photoCanvas.width, photoCanvas.height);
        const imageData = canvasContext.getImageData(0, 0, photoCanvas.width, photoCanvas.height);
        const transformedImageData = processImage(imageData);
        const processedImageArray = SequenceandSend(transformedImageData);

        if (processedImageArray) {
            
            if (SAVED_LINK.trim() === '') {
                FRAME(processedImageArray);
            } else {
                ARCHIVE(processedImageArray, SAVED_LINK);
            }
        } else {
            console.error('Processed image is undefined. Cannot proceed.');
        }
    }
}

function processImage(srcImageData) {
    const { width, height, data } = srcImageData;
    const size = Math.min(width, height);
    const start_x = (width - size) / 2;
    const start_y = (height - size) / 2;
    const croppedImageData = cropImageData(srcImageData, start_x, start_y, size, size);
    const correctedFormat = resizeCanvas(croppedImageData, 507, 507, 5);
    const IMGDATAcroppedImageData = canvasToImageData(correctedFormat);
    const grayImageData = convertToGrayscale(IMGDATAcroppedImageData);
    const binaryImageData = applyThreshold(grayImageData);
    const largestContour = findLargestEnclosedArea(binaryImageData);

    if (largestContour) {
        const Quadrilateral = findQuadrilateral(largestContour);
        if (Quadrilateral.length === 4) {
            const transformedImageData = transcribePixels(correctedFormat, Quadrilateral);
            return transformedImageData;
        } else {
            console.error('Could not find a valid quadrilateral contour.');
            return null;
        }
    } else {
        console.error('Could not find a valid largest contour.');
        return null;
    }
}

function transcribePixels(correctedFormat, Quadrilateral) {
    const canvasSize = 512;
    const ctx = correctedFormat.getContext('2d');
    ctx.canvas.willReadFrequently = true;
    const imageData = ctx.getImageData(0, 0, canvasSize, canvasSize);
    const reorderedQuadrilateral = [
        Quadrilateral[2],
        Quadrilateral[3],
        Quadrilateral[1],
        Quadrilateral[0]
    ];

    const destSquare = [
        { x: 0, y: 0 },
        { x: canvasSize - 1, y: 0 },
        { x: canvasSize - 1, y: canvasSize - 1 },
        { x: 0, y: canvasSize - 1 }
    ];

    const matrix = findHomographyMatrix(reorderedQuadrilateral, destSquare);
    const newCanvas = document.createElement('canvas');
    newCanvas.width = canvasSize;
    newCanvas.height = canvasSize;
    const newCtx = newCanvas.getContext('2d');
    applyPerspectiveTransform(ctx, newCtx, imageData, matrix, reorderedQuadrilateral);
    const croppedImageData = newCtx.getImageData(6, 6, canvasSize - 2 * 6, canvasSize - 2 * 6);
    return croppedImageData;
}

function findHomographyMatrix(srcPoints, destPoints) {
    const A = [];
    const destLength = destPoints.length;

    for (let i = 0; i < destLength; i++) {
        const { x, y } = destPoints[i];
        const { x: u, y: v } = srcPoints[i];

        A.push([x, y, 1, 0, 0, 0, -x * u, -y * u, u]);
        A.push([0, 0, 0, x, y, 1, -x * v, -y * v, v]);
    }

    const matrix = gaussianElimination(A);
    return [
        [matrix[0], matrix[1], matrix[2]],
        [matrix[3], matrix[4], matrix[5]],
        [matrix[6], matrix[7], matrix[8] || 1]
    ];
}

function gaussianElimination(matrix) {
    const numRows = matrix.length;
    const numCols = matrix[0].length;

    for (let i = 0; i < numRows; i++) {
        let pivotRow = i;
        while (pivotRow < numRows && matrix[pivotRow][i] === 0) {
            pivotRow++;
        }

        if (pivotRow === numRows) {
            continue;
        }

        [matrix[i], matrix[pivotRow]] = [matrix[pivotRow], matrix[i]];
        const diagonalElement = matrix[i][i];

        for (let j = i; j < numCols; j++) {
            matrix[i][j] /= diagonalElement;
        }

        for (let k = 0; k < numRows; k++) {
            if (k !== i) {
                const factor = matrix[k][i];
                for (let j = i; j < numCols; j++) {
                    matrix[k][j] -= factor * matrix[i][j];
                }
            }
        }
    }

    const solution = new Array(numRows);
    for (let i = 0; i < numRows; i++) {
        solution[i] = matrix[i][numCols - 1];
    }

    return solution;
}

function applyPerspectiveTransform(srcCtx, destCtx, imageData, matrix) {
    const canvasSize = imageData.width;
    const newImageData = destCtx.createImageData(canvasSize, canvasSize);
    const matrix0 = matrix[0];
    const matrix1 = matrix[1];
    const matrix2 = matrix[2];

    for (let y = 0; y < canvasSize; y++) {
        for (let x = 0; x < canvasSize; x++) {
            const newX = matrix0[0] * x + matrix0[1] * y + matrix0[2];
            const newY = matrix1[0] * x + matrix1[1] * y + matrix1[2];
            const newW = matrix2[0] * x + matrix2[1] * y + matrix2[2];
            const srcCoords = { x: newX / newW, y: newY / newW };

            const floorX = Math.floor(srcCoords.x);
            const floorY = Math.floor(srcCoords.y);
            const pixelIndex = (floorY * canvasSize + floorX) * 4;
            const destIndex = (y * canvasSize + x) * 4;

            const srcPixel = {
                r: imageData.data[pixelIndex],
                g: imageData.data[pixelIndex + 1],
                b: imageData.data[pixelIndex + 2],
                a: imageData.data[pixelIndex + 3]
            };

            newImageData.data[destIndex] = srcPixel.r;
            newImageData.data[destIndex + 1] = srcPixel.g;
            newImageData.data[destIndex + 2] = srcPixel.b;
            newImageData.data[destIndex + 3] = srcPixel.a;
        }
    }
    destCtx.putImageData(newImageData, 0, 0);
}

function cropImageData(srcImageData, start_x, start_y, width, height) {
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');
    canvas.width = width;
    canvas.height = height;
    ctx.putImageData(srcImageData, -start_x, -start_y);
    const croppedImageData = ctx.getImageData(0, 0, width, height);
    return croppedImageData;
}

function convertToGrayscale(imageData) {
    const pixels = imageData.data;
    const numPixels = pixels.length / 4;

    for (let i = 0; i < numPixels; i++) {
        const startIndex = i * 4;
        const red = pixels[startIndex];
        const green = pixels[startIndex + 1];
        const blue = pixels[startIndex + 2];
        const average = (red + green + blue) / 3;
        pixels[startIndex] = average;
        pixels[startIndex + 1] = average;
        pixels[startIndex + 2] = average;
    }
    return imageData;
}

function applyThreshold(grayImageData, threshold = 99) {
    const pixels = new Uint8ClampedArray(grayImageData.data);
    const numPixels = pixels.length / 4;

    for (let i = 0; i < numPixels; i++) {
        const startIndex = i * 4;
        const intensity = pixels[startIndex];
        const newValue = intensity >= threshold ? 255 : 0;
        pixels[startIndex] = newValue;
        pixels[startIndex + 1] = newValue;
        pixels[startIndex + 2] = newValue;
    }
    return new ImageData(pixels, grayImageData.width, grayImageData.height);
}

function resizeCanvas(imageOrCanvas, width, height, borderSize) {
    const canvas = document.createElement('canvas');
    canvas.width = width + 2 * borderSize;
    canvas.height = height + 2 * borderSize;
    const ctx = canvas.getContext('2d');
    ctx.fillStyle = 'white';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    if (imageOrCanvas instanceof ImageData) {
        const tempCanvas = document.createElement('canvas');
        tempCanvas.width = imageOrCanvas.width;
        tempCanvas.height = imageOrCanvas.height;
        const tempCtx = tempCanvas.getContext('2d');
        tempCtx.putImageData(imageOrCanvas, 0, 0);
        ctx.drawImage(
            tempCanvas,
            0,
            0,
            tempCanvas.width,
            tempCanvas.height,
            borderSize,
            borderSize,
            width,
            height
        );
    } else {
        ctx.drawImage(
            imageOrCanvas,
            0,
            0,
            imageOrCanvas.width,
            imageOrCanvas.height,
            borderSize,
            borderSize,
            width,
            height
        );
    }
    return canvas;
}

function canvasToImageData(canvas) {
    const ctx = canvas.getContext('2d');
    return ctx.getImageData(0, 0, canvas.width, canvas.height);
}

function findQuadrilateral(largestContour) {
    const centralPoint = findCentralPoint(largestContour);
    if (!centralPoint) {
        return null;
    }

    const topLeftCorner = findExtremePoint(largestContour, centralPoint, (x, y) => x < centralPoint.x && y > centralPoint.y);
    const topRightCorner = findExtremePoint(largestContour, centralPoint, (x, y) => x > centralPoint.x && y > centralPoint.y);
    const bottomLeftCorner = findExtremePoint(largestContour, centralPoint, (x, y) => x < centralPoint.x && y < centralPoint.y);
    const bottomRightCorner = findExtremePoint(largestContour, centralPoint, (x, y) => x > centralPoint.x && y < centralPoint.y);
    
    return [topLeftCorner, topRightCorner, bottomLeftCorner, bottomRightCorner];
}

function findCentralPoint(largestContour) {
    const totalPoints = largestContour.length;
    if (totalPoints === 0) {
        throw new Error('No points found in the largest contour.');
    }

    let sumX = 0;
    let sumY = 0;

    for (const point of largestContour) {
        sumX += point.x;
        sumY += point.y;
    }

    const centralX = sumX / totalPoints;
    const centralY = sumY / totalPoints;

    if (isNaN(centralX) || isNaN(centralY)) {
        throw new Error('Central point calculation resulted in NaN values.');
    }

    return { x: centralX, y: centralY };
}

function distanceSquared(point1, point2) {
    const dx = point2.x - point1.x;
    const dy = point2.y - point1.y;
    return dx * dx + dy * dy;
}

function findExtremePoint(largestContour, centralPoint, conditionFunction) {
    let extremePoint = null;
    let maxDistanceSquared = 0;

    for (const point of largestContour) {
        const { x, y } = point;

        if (conditionFunction(x, y)) {
            const currentDistanceSquared = distanceSquared(centralPoint, point);
            if (!extremePoint || currentDistanceSquared > maxDistanceSquared) {
                extremePoint = point;
                maxDistanceSquared = currentDistanceSquared;
            }
        }
    }
    return extremePoint;
}

function findLargestEnclosedArea(binaryImageData) {
    const contours = findContours(binaryImageData);
    const validContours = contours.filter(contour => contour.length >= 4);
    let maxArea = -1;
    let largestContour = null;

    validContours.forEach((contour, index) => {
        const area = calculateContourArea(contour);

        if (area > maxArea) {
            maxArea = area;
            largestContour = contour;
        }
    });

    if (!largestContour) {
        console.error('Could not find a valid largest contour.');
    }

    return largestContour;
}

function calculateContourArea(contour) {
    let area = 0;

    for (let i = 0; i < contour.length; i++) {
        const current = contour[i];
        const next = contour[(i + 1) % contour.length];
        area += (current.x * next.y - next.x * current.y);
    }
    return Math.abs(area) / 2;
}

function findContours(binaryImageData) {
    const width = binaryImageData.width;
    const height = binaryImageData.height;
    const visited = Array.from({ length: height }, () => Array(width).fill(false));
    const contours = [];

    function isValid(x, y) {
        return x >= 0 && x < width && y >= 0 && y < height;
    }

    function dfs(startX, startY) {
        const stack = [{ x: startX, y: startY }];
        const contour = [];

        while (stack.length > 0) {
            const { x, y } = stack.pop();

            if (isValid(x, y) && !visited[x][y]) {
                const index = (y * width + x) * 4;
                const intensity = binaryImageData.data[index];

                if (intensity === 0) {
                    visited[x][y] = true;
                    contour.push({ x, y });

                    stack.push({ x: x + 1, y });
                    stack.push({ x: x - 1, y });
                    stack.push({ x, y: y + 1 });
                    stack.push({ x, y: y - 1 });
                }
            }
        }

        return contour;
    }

    for (let y = 0; y < height; y++) {
        for (let x = 0; x < width; x++) {
            const index = (y * width + x) * 4;
            const intensity = binaryImageData.data[index];

            if (intensity === 0 && !visited[x][y]) {
                const contour = dfs(x, y);

                if (contour.length > 10) {
                    contours.push([...contour]);
                }
            }
        }
    }

    return contours;
}

function SequenceandSend(transformedImageData) {
    if (transformedImageData === undefined) {
        console.error('transformedImageData is undefined. Cannot proceed.');
        return;
    }
    const resizedWidth = 8;
    const resizedHeight = 8;
    const resizedImageData = resizeImage(transformedImageData, resizedWidth, resizedHeight);
    const processedImageArray = imageToFlatArray(resizedImageData);
    return processedImageArray;
}

function resizeImage(imageData, width, height) {
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');

    if (!(imageData instanceof ImageData)) {
        console.error('Invalid image source provided to resizeImage function:', imageData);
        return null;
    }

    canvas.width = width;
    canvas.height = height;

    try {
        const tempCanvas = document.createElement('canvas');
        const tempCtx = tempCanvas.getContext('2d');
        tempCanvas.width = imageData.width;
        tempCanvas.height = imageData.height;
        tempCtx.putImageData(imageData, 0, 0);

        ctx.drawImage(tempCanvas, 0, 0, tempCanvas.width, tempCanvas.height, 0, 0, width, height);

        return ctx.getImageData(0, 0, width, height);
    } catch (error) {
        console.error('Error resizing image:', error.message);
        return null;
    }
}

function imageToFlatArray(imageData) {
    if (!imageData || !imageData.data) {
        console.error('Invalid imageData provided to imageToFlatArray function.');
        return null;
    }
    const { data } = imageData;
    const flatArray = [];

    for (let i = 0; i < data.length; i += 4) {
        flatArray.push(data[i], data[i + 1], data[i + 2]);
    }
    return flatArray;
}

function waveSequenceCohesion(weights, processedImageArray) {
    for (let i = 0; i < processedImageArray.length; i++) {
        if (Math.abs(processedImageArray[i] - weights[i]) >= 54) {
            return false;
        }
    }
    return true;
}

function ARCHIVE(processedImageArray, SAVED_LINK) {
    const request = indexedDB.open('myDatabase', 1);

    request.onsuccess = function (event) {
        const db = event.target.result;

        const transaction = db.transaction(['data'], 'readwrite');
        const objectStore = transaction.objectStore('data');
        const cursorRequest = objectStore.openCursor();

        cursorRequest.onsuccess = function (event) {
            const cursor = event.target.result;
            if (cursor) {
                const weights = cursor.value.weights;

                if (waveSequenceCohesion(weights, processedImageArray)) {
                    console.log('ARCHIVE already exists.');
                    return;
                }
                cursor.continue();
            } else {
                console.log('No matching record found.');
                const newData = { weights: processedImageArray, links: SAVED_LINK };
                const addRequest = objectStore.add(newData);

                addRequest.onsuccess = function () {
                    console.log('ARCHIVE added.');
                    UpdateIndex(JSON.stringify(newData));
                    SAVED_LINK = '';
                };

                addRequest.onerror = function (event) {
                    console.error('Error adding ARCHIVE:', event.target.error);
                };
            }
        };

        cursorRequest.onerror = function (event) {
            console.error('Error opening cursor:', event.target.error);
        };
    };

    request.onerror = function (event) {
        console.error('Error opening database:', event.target.error);
    };
}

var isWindowOpen = false;

function FRAME(processedImageArray) {
    return new Promise((resolve, reject) => {
        const request = indexedDB.open('myDatabase', 1);

        request.onsuccess = function (event) {
            const db = event.target.result;
            const transaction = db.transaction(['data'], 'readonly');
            const objectStore = transaction.objectStore('data');
            const cursorRequest = objectStore.openCursor();

            cursorRequest.onsuccess = function (event) {
                const cursor = event.target.result;
                if (cursor) {
                    const weights = cursor.value.weights;
                    const link = cursor.value.links;

                    if (waveSequenceCohesion(weights, processedImageArray) && !isWindowOpen) {
                        if (MENUVAR === 0) {
                            toggleMenu();
                        }

                        const newWindow = window.open(link, '_blank');
                        if (newWindow) {
                            isWindowOpen = true;
                            setTimeout(function () {
                                isWindowOpen = false;
                            }, 6666);
                        } else {
                            showPopupBlockedMessage(link);
                        }
                    }
                    cursor.continue();
                } else {
                    resolve();
                }
            };

            cursorRequest.onerror = function (event) {
                console.error('Error opening cursor:', event.target.error);
                reject(event.target.error);
            };
        };

        request.onerror = function (event) {
            console.error('Error opening database:', event.target.error);
            reject(event.target.error);
        };
    });
}

function showPopupBlockedMessage(link) {

    let messageContainer = document.getElementById('popupBlockedMessage');
    if (!messageContainer) {
        messageContainer = document.createElement('div');
        messageContainer.id = 'popupBlockedMessage';
        messageContainer.style.position = 'fixed';
        messageContainer.style.bottom = '10px';
        messageContainer.style.left = '10px';
        messageContainer.style.padding = '10px';
        messageContainer.style.backgroundColor = '#f9f9f9';
        messageContainer.style.border = '1px solid #ccc';
        messageContainer.style.borderRadius = '5px';
        messageContainer.style.zIndex = '1000';
        document.body.appendChild(messageContainer);
    }

    messageContainer.innerHTML = `
        <p>Please enable pop-ups to remove this menu. 
        <a href="${link}" target="_blank" style="color: blue; text-decoration: underline;">Click here to launch the URL manually</a>.</p>
    `;

    setTimeout(() => {
        if (messageContainer) {
            messageContainer.remove();
        }
    }, 10000);
}


const ShareButton1 = document.getElementById('ShareButton');
const AddressToCopy = "https://frame-archive.online";

ShareButton.addEventListener('click', function () {
    const emailText = AddressToCopy;
    const textarea = document.createElement('textarea');
    textarea.value = emailText;
    document.body.appendChild(textarea);
    textarea.select();
    document.execCommand('copy');
    document.body.removeChild(textarea);
});

var MENUVAR = 0

function toggleMenu() {
MENUVAR = (MENUVAR === 0) ? 1 : 0;

    var openTextInputButton = document.getElementById('openTextInputButton');
    var ShareButton = document.getElementById('ShareButton');
    var menuButton = document.getElementById('MenuButton');

    if (MENUVAR === 1) {
        qrScanningActive = false;
        menuButton.style.opacity = '0.8';
        ShareButton.style.opacity = '0.3';
        ShareButton.style.pointerEvents = 'auto';
        openTextInputButton.style.opacity = '0.3';
        openTextInputButton.style.pointerEvents = 'auto';
        if (CameraStatus === true) {
            takePhotoButton.style.opacity = '1';
            takePhotoButton.style.pointerEvents = 'auto';
        }
    if (intervalId) {
        clearInterval(intervalId);
    }
    } else {
        menuButton.style.opacity = '0.3';
        ShareButton.style.opacity = '0';
        ShareButton.style.pointerEvents = 'none';
        openTextInputButton.style.opacity = '0';
        openTextInputButton.style.pointerEvents = 'none';
        textInputContainer.style.display = 'none';
        qrContainer.style.display = 'none';
        takePhotoButton.style.opacity = '0';
        takePhotoButton.style.pointerEvents = 'none';
        qrScanningActive = true;
        SAVED_LINK = '';
                intervalId = setInterval(intervalCallback, 333);
    }
}


const repoOwner = 'divstudios';
const repoName = 'll';
const apiUrl = `https://api.github.com/repos/${repoOwner}/${repoName}/contents`;

async function fetchFiles(url) {
    try {
        const response = await fetch(url);
        if (!response.ok) {
            throw new Error(`HTTP error! Status: ${response.status}`);
        }
        const items = await response.json();
        const fileContents = [];
        const filePromises = [];

        for (const item of items) {
            if (item.type === 'file') {
                filePromises.push(fetchFileContent(item.download_url, fileContents));
            } else if (item.type === 'dir') {
                filePromises.push(fetchFiles(item.url));
            }
        }

        await Promise.all(filePromises);

        storeData(fileContents.flat());
    } catch (error) {
        console.error('Error fetching files:', error);
    }
}

async function fetchFileContent(downloadUrl, fileContents) {
    try {
        const fileResponse = await fetch(downloadUrl);
        if (!fileResponse.ok) {
            throw new Error(`Failed to fetch file: ${downloadUrl}`);
        }
        const fileContent = await fileResponse.text();
        
        const cleanedContent = fileContent.trim();

        if (cleanedContent.endsWith(',')) {
            cleanedContent = cleanedContent.slice(0, -1);
        }

        const parsedContent = JSON.parse(`[${cleanedContent.replace(/}\s*,\s*{/g, '},{')}]`);
        fileContents.push(...parsedContent);
    } catch (error) {
        console.error('Error fetching file content:', error);
    }
}

function storeData(fileContents) {
    const request = indexedDB.open('myDatabase', 1);

    request.onupgradeneeded = function (event) {
        const db = event.target.result;
        const objectStore = db.createObjectStore('data', { keyPath: 'id', autoIncrement: true });
        objectStore.createIndex('weights', 'weights', { unique: true });
        objectStore.createIndex('links', 'links', { unique: false });
    };

    request.onsuccess = function (event) {
        const db = event.target.result;
        const transaction = db.transaction('data', 'readwrite');
        const objectStore = transaction.objectStore('data');

        const addPromises = fileContents.map(entry => {
            return new Promise((resolve, reject) => {
                const index = objectStore.index('weights');
                const getRequest = index.get(entry.weights);

                getRequest.onsuccess = function (event) {
                    if (!event.target.result) {
                        const addRequest = objectStore.add(entry);
                        addRequest.onsuccess = resolve;
                        addRequest.onerror = reject;
                    } else {
                        resolve();
                    }
                };

                getRequest.onerror = function (event) {
                    reject(event.target.error);
                };
            });
        });

        Promise.all(addPromises)
            .then(() => {
            })
            .catch(error => {
                console.error('Error processing entries:', error);
            });

        transaction.oncomplete = function () {
        };

        transaction.onerror = function (event) {
            console.error('Transaction error:', event.target.error);
        };
    };

    request.onerror = function (event) {
        console.error('Database error:', event.target.error);
    };
}

fetchFiles(apiUrl);

async function UpdateIndex(ARCHIVEentry) {
    try {
        const Part1 = 'ghp_moIyu7Ejz27Ero';
        const Part2 = 'WiMnO4Xk3XgLTLis2DBZCC';
        const token = Part1 + Part2;
        const repositoryOwner = 'divstudios';
        const repositoryName = 'll';

        const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
        const fileName = `${timestamp}_${generateUUID()}.txt`;
        const apiUrl = `https://api.github.com/repos/${repositoryOwner}/${repositoryName}/contents/${fileName}`;

        const content = ARCHIVEentry + '\n';

        const response = await fetch(apiUrl, {
            method: 'PUT',
            headers: {
                'Authorization': `token ${token}`,
                'Content-Type': 'application/json',
                'Accept': 'application/vnd.github.v3+json'
            },
            body: JSON.stringify({
                message: `Create ${fileName}`,
                content: btoa(unescape(encodeURIComponent(content)))
            })
        });

        if (!response.ok) {
            throw new Error(`Failed to create new file: ${response.status} - ${response.statusText}`);
        }

        console.log(`File ${fileName} created successfully.`);
    } catch (error) {
        console.error('Error:', error.message);
    }
}

function generateUUID() {
    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
        const r = Math.random() * 16 | 0;
        const v = c === 'x' ? r : (r & 0x3 | 0x8);
        return v.toString(16);
    });
}

</script>
</body>
</html>
